---
title: 使用令牌桶实现限流(内容部分来自网络)
date: 2018-01-19
tags: [限流]
categories: [令牌桶]
---

##### 导论
这段时间业务上有限流需求，也研究令牌桶的限流和其他的各种限流，个人令牌桶限流比较合理，也学习了一段时间，这篇博客也是借助同事的文档完成，权当记录加深印象。该文章之后介绍令牌桶的原理，怎么实现限流，具体业务场景大家还是适合当前场景的限流方式好了。

##### 正文
看到一句不错的总结：作为后台服务，通常有一个处理极限PPS（packets per second），如果请求超过了这个处理能力，可能会出现“雪崩效应”，因此后台服务需要有过载保护机制。

###### 令牌桶是什么
这里的“令牌桶”是指网络设备的内部存储池，而“令牌”则是指以给定速率填充令牌桶的虚拟信息包。可以这么简单理解，“令牌桶”可以理解为一个水桶，而“令牌”则可以理解为通过一根水管流到水桶中的水。

交换机在接收每个帧时都将添加一个令牌到令牌桶中，但这个令牌桶底部有一个孔，不断地按你指定作为平均通信速率（单位为b/s）的速度领出令牌（也就是从桶中删除令牌的意思）。相当于一个水桶的上边连接一根进水的水管，而下边又连接一根连接到用水的地方的出水管。在每次向令牌桶中添加新的令牌包时，交换机都会检查令牌桶中是否有足够容量（也就是在要向桶水加水前，先要检查是桶内否已满了），如果没有足够的空间，包将被标记为不符规定的包，这时在包上将发生指定监管器中规定的行为（丢弃或标记），就相当于如果当前水桶满了，但上边水管的水还是来了，这时要么就是让这些水白白流到桶外，要么把这些水用其它容器先装起来，等水桶中不再满水时再倒进去，供用户使用。

![image](http://otqvaruzt.bkt.clouddn.com/p1.png)

###### 原理
令牌桶填满的时间长短是由令牌桶深度（也就是容量，单位为bit，类似于水桶的的深度）、令牌漏出速率（类似桶下边接的水管的水速）和超过平均速率的突发通信流（类似于上桶上边水管突发的急速水流）持续的时间三个方面共同决定的。 令牌桶的大小利用突发时长上限乘以点对点传输时的帧数限制得出（也就类似突发水流持续的时间*突发水流的流速）。如果突发时间比较短，令牌桶不会溢出，在通信流上不会发生行为。但是，如果突发时间比较长，并且速率比较高，令牌桶将溢出，这时将对突发过程中的帧采取相应的流监管策略行为（也就是在水桶满水后对溢出的水的处理方法）

###### 怎么限流
常用的限流算法有两种：漏桶算法和令牌桶算法。

- 漏桶算法

漏桶算法思路很简单，水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会直接溢出，可以看出漏桶算法能强行限制数据的传输速率。

![image](http://otqvaruzt.bkt.clouddn.com/p2.png)

- 令牌桶算法


对于很多应用场景来说，除了要求能够限制数据的平均传输速率外，还要求允许某种程度的突发传输。这时候漏桶算法可能就不合适了，令牌桶算法更为适合。如图2所示，令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。

![image](http://otqvaruzt.bkt.clouddn.com/p3.png)

###### Google封装的工具类
放心，各个公司的开源工具类已经帮我封装好了，直接使用就好了。
```
public double acquire() {
        return acquire(1);
    }

 public double acquire(int permits) {
        checkPermits(permits);  //检查参数是否合法（是否大于0）
        long microsToWait;
        synchronized (mutex) { //应对并发情况需要同步
            microsToWait = reserveNextTicket(permits, readSafeMicros()); //获得需要等待的时间 
        }
        ticker.sleepMicrosUninterruptibly(microsToWait); //等待，当未达到限制时，microsToWait为0
        return 1.0 * microsToWait / TimeUnit.SECONDS.toMicros(1L);
    }

private long reserveNextTicket(double requiredPermits, long nowMicros) {
        resync(nowMicros); //补充令牌
        long microsToNextFreeTicket = nextFreeTicketMicros - nowMicros;
        double storedPermitsToSpend = Math.min(requiredPermits, this.storedPermits); //获取这次请求消耗的令牌数目
        double freshPermits = requiredPermits - storedPermitsToSpend;

        long waitMicros = storedPermitsToWaitTime(this.storedPermits, storedPermitsToSpend)
                + (long) (freshPermits * stableIntervalMicros); 

        this.nextFreeTicketMicros = nextFreeTicketMicros + waitMicros;
        this.storedPermits -= storedPermitsToSpend; // 减去消耗的令牌
        return microsToNextFreeTicket;
    }

private void resync(long nowMicros) {
        // if nextFreeTicket is in the past, resync to now
        if (nowMicros > nextFreeTicketMicros) {
            storedPermits = Math.min(maxPermits,
                    storedPermits + (nowMicros - nextFreeTicketMicros) / stableIntervalMicros);
            nextFreeTicketMicros = nowMicros;
        }
    }
```

##### 总结
令牌桶笔者也还在研究中，就写这么多，内容不全，后续会完善。