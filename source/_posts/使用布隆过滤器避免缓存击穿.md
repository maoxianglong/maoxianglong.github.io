---
title: 使用布隆过滤器避免缓存击穿
date: 2018-05-09
tags: [缓存]
categories: [缓存]
---

#### 是什么？

布隆过滤器是什么？我是这么理解的，它是一个高性能，大量存储数据的集合。它的特点是能存放大量数据，使用哈希函数和二进制数组来判断数据是否存在于过滤器中，采用的哈希函数越多，对应数组容量越大，耗内存越大，但误伤率低，准确性高，反之亦然。

#### 怎么用？

直接加入google的guava，google的程序员已经帮我们做了完美的布隆过滤器的封装。使用19.0或以上版本都ok。

```
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>20.0</version>
</dependency>
```

```
package com.mxl.bloomFilter;

import com.google.common.hash.BloomFilter;
import com.google.common.hash.Funnels;

import java.util.HashSet;
import java.util.UUID;

/**
 * @author MAO
 * @Date 2018-05-09
 */
public class BloomFilterTest {

    private static BloomFilter<Integer> bf = null;
    private static HashSet<Integer> set = null;
    private static final Integer NUMBER = 1000000;

    private static void addEletoBloomFilter(){

        //采用工厂方法实例化BloomFilter对象
        //第一个参数:布隆过滤器的泛型，实际场景中一般用来存放用户唯一编码，即userCode
        //第二个参数:布隆过滤器的容量，一般容量设置为实际容量的1.5倍，因为布隆过滤器的算法
        // 复杂，存放容易，删除一个元素很复杂，所以预设容量最好是实际容量的1.2-1.5倍
        //第三个参数:布隆过滤器的误伤率，默认是0.03。布隆过滤器由于使用哈希函数(hsah function)的
        // 过滤机制，算法复杂，其存在一定的hash碰撞率,存在一定的误伤率，这个误伤率可以
        // 设置，误伤率越小，采用的哈希函数越多，所需容量自然就越大，越准确，根据实际场景
        //设置。
        bf = BloomFilter.create(Funnels.integerFunnel(),NUMBER,0.01);

        for (int i =0; i < NUMBER; i++){
            bf.put(i);
        }

    }

    private static void addEleToHashSet(){

        set = new HashSet<Integer>();

        for(int i = 0; i < NUMBER; i++){
            set.add(i);
        }
    }

    public static void main(String[] args) {

        Integer flag = -1;
        int right = 0;
        int wrong = 0;
        addEletoBloomFilter();
        addEleToHashSet();

        for (int i = 1; i < 9999; i++){

            if(i%100 == 0){
                flag = i/100;
            }else {
                flag = UUID.randomUUID().hashCode();
            }

            if (bf.mightContain(flag)){
                if(set.contains(flag)){
                    right++;
                }else{
                    wrong++;
                }
            }

        }

        System.out.println("正确：" + right);
        System.out.println("错误：" + wrong);
    }

}
```

这里我先设置误伤率为0.01，执行结果如下：
```
正确：100
错误：100
```
可见10000次的判断，误伤率在0.01的情况下错误次数为100，符合预期。
之后我将误伤率更改为0.001，执行结果如下：
```
正确：100
错误：12
```
10000次的判断，误伤率在0.001的情况下错误次数为12，符合预期。

#### 原理
借用网络上的一张图片，自行理解。

![image](http://otqvaruzt.bkt.clouddn.com/2012071317402283.png)

x,y,z相当于三个hash function，下面是二进制数组，每个元素通过三个hash function判断之后得到二进制变量，若通过三个hash function判断之后数组里面为1，则说明该数组在可能在布隆过滤器存在，若有一个为0，则说明不存在。

#### 使用场景
- 提升查询未命中的效率。在从磁盘加载数据前，先从布隆过滤器中判断数据是否存在。如果不存在，就直接返回。这样可以减少磁盘访问，提升响应速度。上面代码10000次判断，假设是黑客同事10000次并发访问，若不设置缓存或者设置缓存直接被击穿怼到数据库，一般MySQL支持的最大连接数300-700,10000次并发同时怼到数据库，肯定会挂掉，所以使用布隆过滤器能良好的防止缓存被击穿的恶意攻击。
-  减少存储成本。保存黑名单比较容易想到的是使用 Map、Set 等数据结构。这些数据结构在面临海量数据时，需要消耗大量的内存。使用布隆过滤器，就可以降低资源的消耗。
-  解决 java 服务 gc 耗时过长的问题。布隆过滤器对于 java gc 的一个便利之处，在于可以将布隆过滤器使用的内存直接放到老年代，从而减少 YoungGC 需要拷贝的内存。
