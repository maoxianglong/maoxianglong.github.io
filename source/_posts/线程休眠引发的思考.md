---
title: 线程休眠引发的思考
date: 2017-10-19
tags: [异常]
categories: [问题思考]
---

#### 导论

今天在开发的过程中发现了线程休眠的一些问题，问题是小问题，但是却是笔者在学习线程中的过程中所忽略。现在想想真是惊险，要是这样的代码直接放在测试环境，不知道会被领导骂成什么样。


#### 问题

##### 问题描述

1、线程休眠获取互斥锁的对象是否是静态（即类公用）。

2、启动线程的对象是否是同一个。

3、线程休眠是抱着锁休眠的，我不睡醒手都别想进来，但是问题却不太一样。

##### 问题代码

```
package com.mxl.thread;

public class ThreadTest05 {

//    private static final Object o = new Object();
    private final Object o = new Object();

    private static final ThreadTest05 thread01 = new ThreadTest05();

    public static void main(String[] args) {
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                new ThreadTest05().show();
//                thread01.show();
            }
        }, "t1");

        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                new ThreadTest05().show();
//                thread01.show();
            }
        }, "t2");

        Thread t3 = new Thread(new Runnable() {
            @Override
            public void run() {
                new ThreadTest05().show();
//                thread01.show();
            }
        }, "t3");

        t1.start();
        t2.start();
        t3.start();

    }

    public void show() {
        synchronized (o){
            try {
                System.out.println(Thread.currentThread().getName() + "开始休眠");
                Thread.sleep(3000);
                System.out.println("休眠完成" + Thread.currentThread().getName() + "Thread is running");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

```

上面的代码看似没毛病，看看输出吧

```
t1开始休眠
t3开始休眠
t2开始休眠
休眠完成t1Thread is running
休眠完成t3Thread is running
休眠完成t2Thread is running
```

三个线程居然同时进入了互斥代码块，同事休眠，同时唤醒，惊呆了。假如t1进入互斥代码快并且睡着了，那么其他两个线程应该乖乖在外面等着，为啥是一起进入还同时休眠了。

##### 解决办法

###### 办法一

```
package com.mxl.thread;

public class ThreadTest05 {

    //将被锁的对象变为静态不可变
    private static final Object o = new Object();
//    private final Object o = new Object();

    private static final ThreadTest05 thread01 = new ThreadTest05();

    public static void main(String[] args) {
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                new ThreadTest05().show();
//                thread01.show();
            }
        }, "t1");

        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                new ThreadTest05().show();
//                thread01.show();
            }
        }, "t2");

        Thread t3 = new Thread(new Runnable() {
            @Override
            public void run() {
                new ThreadTest05().show();
//                thread01.show();
            }
        }, "t3");

        t1.start();
        t2.start();
        t3.start();

    }

    public void show() {
        synchronized (o){
            try {
                System.out.println(Thread.currentThread().getName() + "开始休眠");
                Thread.sleep(3000);
                System.out.println("休眠完成" + Thread.currentThread().getName() + "Thread is running");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

```

我将被锁的Object对象变为静态，这个时候再看输出。

```
t1开始休眠
休眠完成t1Thread is running
t3开始休眠
休眠完成t3Thread is running
t2开始休眠
休眠完成t2Thread is running
```

没毛病了，线程都是按顺序来的。再看看第二种办法。

###### 办法二

```
package com.mxl.thread;

public class ThreadTest05 {

//    private static final Object o = new Object();
    private final Object o = new Object();

    //将启动线程的对象变为同一个静态对象
    private static final ThreadTest05 thread01 = new ThreadTest05();

    public static void main(String[] args) {
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
//                new ThreadTest05().show();
                //使用上面定义的静态对象调用互斥代码快，下面两个线程也一样
                thread01.show();
            }
        }, "t1");

        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
//                new ThreadTest05().show();
                thread01.show();
            }
        }, "t2");

        Thread t3 = new Thread(new Runnable() {
            @Override
            public void run() {
//                new ThreadTest05().show();
                thread01.show();
            }
        }, "t3");

        t1.start();
        t2.start();
        t3.start();

    }

    public void show() {
        synchronized (o){
            try {
                System.out.println(Thread.currentThread().getName() + "开始休眠");
                Thread.sleep(3000);
                System.out.println("休眠完成" + Thread.currentThread().getName() + "Thread is running");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

```

我将启动线程的对象变为同一个静态对象，并且使用同一个对象调用护持代码块，看看结果。

```
t1开始休眠
休眠完成t1Thread is running
t3开始休眠
休眠完成t3Thread is running
t2开始休眠
休眠完成t2Thread is running
```

没毛病，看了这两种方法是否已经意识到错误处在哪里了，做个总结。

#### 总结

被锁的对象一定要是多个线程共享，否则每个线程各执一份被锁对象，那么多个线程之间各自使用自己的锁，当然互斥代码块也是各自执行各自的，所以当被锁对象不是多个线程共享时，synchronized无法起作用。

看上面的错误代码中的object对象不是多个线程共同享有的，加上static之后就ok了，或者使用同一个对象去启动三个线程，将thread01加上static就好了。

感觉这个表达只有我自己能理解。。。。
