---
title: 多线程下的单例思考
date: 2017-08-23
tags: [jdk,设计模式,单例]
categories: [问题思考]
---

## 一、导论
逛论坛看到一个耐人寻味的问题，单例模式在多线程下会产生什么有趣的问题，花了半个小时玩了玩，在此记录一下。

## 二、单线程下的单例模式
单线程下的单例模式不用细说，随便跑，总是同一个实例，不会产生两个不同的实例，不想多解释了。

## 三、多线程模式下的单例模式
```
package com.mxl.design.model.singleton;

public class TestSingleton {

	public static void main(String[] args) {
		for (int i = 0; i < 3; i++) {
			Thread thread = new Thread(new Runnable() {
				public void run() {
					System.out.println(Thread.currentThread().getName() + " "
							+ Singleton.getInstance().hashCode());
				}

			});
			thread.setName("Thread" + i);
			thread.start();
		}

	}

	static class Singleton {
		// 注意这里都是加上了volatile关键字的
		private static volatile Singleton cache = null;
		private static Object mutexObj = new Object();

		private Singleton() {

		}

		public static Singleton getInstance() {
			Singleton tmp = cache;
			if (tmp == null) {
				tmp = cache;
				synchronized (mutexObj) {
					if (tmp == null) {
						tmp = new Singleton();
						cache = tmp;
					}
				}
			}
			return tmp;
		}
	}
}
```
笔者在测试类TestSingleton中创建了内部类，并使用volatile关键字修饰了实例，多次运行发现问题不小。

第一次运行
```
Thread1 427340025
Thread0 1446427658
Thread2 427340025
```
第二次运行
```
Thread1 863719801
Thread0 863719801
Thread2 863719801

```
第三次运行
```
Thread1 863719801
Thread0 863719801
Thread2 863719801

```
可以发现问题所在，第一次并没有产生单例，后两次确实是产生了单例，这就是问题所在，问题出现在代码32行，后面解释。后来笔者在代码中加上了更详细的注释，继续看看。

## 四、更详细的单例
```
package com.mxl.design.model.singleton;

public class TestSingletonForText {

	public static void main(String[] args) {
		for (int i = 0; i < 3; i++) {
			Thread thread = new Thread(new Runnable() {
				public void run() {
					try {
						System.out.println(Thread.currentThread().getName() + " "
								+ SingletonForText.getInstance().hashCode());
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}

			});
			thread.setName("Thread" + i);
			thread.start();
		}

	}

	public static class SingletonForText {

		// 注意这里都是加上了volatile关键字的
		private static volatile SingletonForText cache = null;
		private static Object mutexObj = new Object();

		private SingletonForText() {

		}

		public static SingletonForText getInstance() throws InterruptedException {
			SingletonForText tmp = cache;
			if (tmp == null) {
				System.out.println(Thread.currentThread().getName() + " : 开始第一个条件判断");
				synchronized (mutexObj) {
					tmp = cache;
					System.out.println(Thread.currentThread().getName() + " : 进入同步块");
					if (tmp == null) {
						System.out.println(Thread.currentThread().getName() + " : 开始第二个条件判断");
						tmp = new SingletonForText();
						Thread.sleep(1000);
						cache = tmp;
					}
					System.out.println(Thread.currentThread().getName() + " : 结束第二个条件判断");
				}
				System.out.println(Thread.currentThread().getName() + " : 结束同步块");
			}
			System.out.println(Thread.currentThread().getName() + " : 结束第一个条件判断");
			return tmp;
		}
	}
}

```
多次执行
第一次执行
```
Thread0 : 开始第一个条件判断
Thread2 : 开始第一个条件判断
Thread1 : 开始第一个条件判断
Thread0 : 进入同步块
Thread0 : 开始第二个条件判断
Thread0 : 结束第二个条件判断
Thread1 : 进入同步块
Thread1 : 结束第二个条件判断
Thread1 : 结束同步块
Thread1 : 结束第一个条件判断
Thread1 : 1113847530
Thread0 : 结束同步块
Thread0 : 结束第一个条件判断
Thread0 : 1113847530
Thread2 : 进入同步块
Thread2 : 结束第二个条件判断
Thread2 : 结束同步块
Thread2 : 结束第一个条件判断
Thread2 : 1113847530

```
第二次执行
```
Thread2 : 开始第一个条件判断
Thread2 : 进入同步块
Thread2 : 开始第二个条件判断
Thread1 : 开始第一个条件判断
Thread0 : 开始第一个条件判断
Thread2 : 结束第二个条件判断
Thread0 : 进入同步块
Thread0 : 结束第二个条件判断
Thread2 : 结束同步块
Thread1 : 进入同步块
Thread0 : 结束同步块
Thread1 : 结束第二个条件判断
Thread2 : 结束第一个条件判断
Thread1 : 结束同步块
Thread1 : 结束第一个条件判断
Thread1 : 820485811
Thread0 : 结束第一个条件判断
Thread0 : 820485811
Thread2 : 820485811

```
第三次执行
```
Thread2 : 开始第一个条件判断
Thread1 : 开始第一个条件判断
Thread0 : 开始第一个条件判断
Thread2 : 进入同步块
Thread2 : 开始第二个条件判断
Thread2 : 结束第二个条件判断
Thread2 : 结束同步块
Thread0 : 进入同步块
Thread2 : 结束第一个条件判断
Thread0 : 结束第二个条件判断
Thread0 : 结束同步块
Thread1 : 进入同步块
Thread1 : 结束第二个条件判断
Thread1 : 结束同步块
Thread1 : 结束第一个条件判断
Thread1 : 1678885403
Thread2 : 1678885403
Thread0 : 结束第一个条件判断
Thread0 : 1678885403

```
这样看好像又没有问题了，仔细检查代码发现synchronize之前赋值的代码都被并发访问了，所以后来cache赋给tmp是起不到作用的，不管cache是否为null,但是同步代码块中tmp = cache;这一步是在同步代码块中，多个线程是不能并发访问的，致使下面的判断tmp是否为null都是符合逻辑的，产生的都是同一个实例，这也是最后抢到资源的线程没有执行第二个条件判断的原因。

## 五、总结
又沿着这条思路发现了单例模式下的不少有意思的东西，比如多线程下采用静态内部类编写单例，或者采用volatile修饰单例懒汉模式下的单例对象等等，后续再记录。